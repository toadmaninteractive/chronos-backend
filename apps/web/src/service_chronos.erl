%% @author Igor compiler
%% @doc Compiler version: igorc 2.1.4
%% DO NOT EDIT THIS FILE - it is machine generated

-module(service_chronos).

-include_lib("stdlib/include/assert.hrl").

-export([
    reply_log_message/2,
    fail_log_message/2,
    reply_log/3,
    fail_log/3,
    recv/2,
    c2s_message_from_json/1,
    c2s_message_to_json/1,
    s2c_message_from_json/1,
    s2c_message_to_json/1
]).

-export_type([
    c2s_message/0,
    s2c_message/0
]).

-callback on_log(State, RpcId, App, Component, Branch, Version, Logs) -> State when
      RpcId :: igor_types:rpc_id(),
      App :: binary(),
      Component :: binary(),
      Branch :: binary(),
      Version :: binary(),
      Logs :: [protocol_chronos:log_entry()].

-type c2s_message() :: {'log', igor_types:rpc_id(), binary(), binary(), binary(), binary(), [protocol_chronos:log_entry()]}.
-type s2c_message() :: {'reply_log', igor_types:rpc_id(), igor_types:int()} | {'fail_log', igor_types:rpc_id(), term()}.

-spec reply_log_message(RpcId, Loaded) -> s2c_message() when
      Loaded :: igor_types:int(),
      RpcId :: igor_types:rpc_id().

reply_log_message(RpcId, Loaded) ->
    ?assert(Loaded =/= undefined),
    {reply_log, RpcId, Loaded}.

-spec fail_log_message(RpcId, Exception) -> s2c_message() when
      RpcId :: igor_types:rpc_id(),
      Exception :: term().

fail_log_message(RpcId, Exception) ->
    {fail_log, RpcId, Exception}.

-spec reply_log(State, RpcId, Loaded) -> State when
      Loaded :: igor_types:int(),
      RpcId :: igor_types:rpc_id().

reply_log(State, RpcId, Loaded) ->
    Message = reply_log_message(RpcId, Loaded),
    web_ws:send(State, service_chronos, Message).

-spec fail_log(State, RpcId, Exception) -> State when
      RpcId :: igor_types:rpc_id(),
      Exception :: term().

fail_log(State, RpcId, Exception) ->
    Message = fail_log_message(RpcId, Exception),
    web_ws:send(State, service_chronos, Message).

-spec recv(Message, State) -> State when
      Message :: c2s_message().

recv({log, RpcId, App, Component, Branch, Version, Logs}, State) ->
    try
        Handler = web_ws:handler(State, service_chronos),
        Handler:on_log(State, RpcId, App, Component, Branch, Version, Logs)
    catch
InvalidData when element(1, InvalidData) =:= invalid_data ->
    fail_log(State, RpcId, InvalidData);
        Reason ->
            ExceptionString = web_ws:format_unknown_error({throw, Reason}),
            fail_log(State, RpcId, {unknown_error, ExceptionString});
        error:Reason:Stacktrace ->
            ExceptionString = web_ws:format_unknown_error({error, Reason, Stacktrace}),
            fail_log(State, RpcId, {unknown_error, ExceptionString})
    end.

-spec c2s_message_from_json(igor_json:json()) -> c2s_message().

c2s_message_from_json(#{<<"method">> := <<"Log">>, <<"id">> := RpcId, <<"params">> := Params}) ->
    [AppJson, ComponentJson, BranchJson, VersionJson, LogsJson] = Params,
    App = igor_json:parse_value(AppJson, string),
    Component = igor_json:parse_value(ComponentJson, string),
    Branch = igor_json:parse_value(BranchJson, string),
    Version = igor_json:parse_value(VersionJson, string),
    Logs = igor_json:parse_value(LogsJson, {list, {custom, fun protocol_chronos:log_entry_from_json/1}}),
    {log, RpcId, App, Component, Branch, Version, Logs}.

-spec c2s_message_to_json(c2s_message()) -> igor_json:json().

c2s_message_to_json({log, RpcId, App, Component, Branch, Version, Logs}) ->
    ?assert(App =/= undefined),
    ?assert(Component =/= undefined),
    ?assert(Branch =/= undefined),
    ?assert(Version =/= undefined),
    ?assert(Logs =/= undefined),
    #{
        <<"method">> => <<"Log">>,
        <<"id">> => RpcId,
        <<"params">> => [
            igor_json:pack_value(App, string),
            igor_json:pack_value(Component, string),
            igor_json:pack_value(Branch, string),
            igor_json:pack_value(Version, string),
            igor_json:pack_value(Logs, {list, {custom, fun protocol_chronos:log_entry_to_json/1}})
        ]
    }.

-spec s2c_message_from_json(igor_json:json()) -> s2c_message().

s2c_message_from_json(#{<<"method">> := <<"Log">>, <<"id">> := RpcId, <<"result">> := Result}) ->
    [LoadedJson] = Result,
    Loaded = igor_json:parse_value(LoadedJson, int),
    {reply_log, RpcId, Loaded};
s2c_message_from_json(#{<<"method">> := <<"Log">>, <<"id">> := RpcId, <<"error">> := #{<<"code">> := 1, <<"data">> := ExceptionJson}}) ->
    Exception = protocol_chronos:invalid_data_from_json(ExceptionJson),
    {fail_log, RpcId, Exception};
s2c_message_from_json(#{<<"method">> := <<"Log">>, <<"id">> := RpcId, <<"error">> := #{<<"code">> := 255, <<"message">> := ExceptionString}}) ->
    Exception = {unknown_error, ExceptionString},
    {fail_log, RpcId, Exception}.

-spec s2c_message_to_json(s2c_message()) -> igor_json:json().

s2c_message_to_json({reply_log, RpcId, Loaded}) ->
    ?assert(Loaded =/= undefined),
    #{
        <<"method">> => <<"Log">>,
        <<"id">> => RpcId,
        <<"result">> => [
            igor_json:pack_value(Loaded, int)
        ]
    };
s2c_message_to_json({fail_log, RpcId, Exception}) when element(1, Exception) =:= invalid_data ->
    #{
        <<"method">> => <<"Log">>,
        <<"id">> => RpcId,
        <<"error">> => #{
            <<"code">> => 1,
            <<"message">> => <<"InvalidData">>,
            <<"data">> => protocol_chronos:invalid_data_to_json(Exception)
        }
    };
s2c_message_to_json({fail_log, RpcId, {unknown_error, ExceptionString}}) ->
    #{
        <<"method">> => <<"Log">>,
        <<"id">> => RpcId,
        <<"error">> => #{
            <<"code">> => 255,
            <<"message">> => ExceptionString
        }
    }.

